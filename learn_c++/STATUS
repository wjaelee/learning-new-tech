------------------------------------------------
Lesson 1: namespace

namespace is a collection of names that help programmers avoid name conflicts.
Especially, as number of functions increase in the codebase, there may be functions
with the same name. Namespace helps us figure out which function we are referring to.
------------------------------------------------

------------------------------------------------
Lesson 2: reference
int a = 5;
int& another_a = a;

difference between reference and pointer
- reference must be initialized
- once reference is assigned, cannot be changed. On the other hand, pointer can be reassigned to point to different var.
- reference does not exist on memory, it is simply an alias of other var. (except for reference in the argument)
- there can't be array of references, references to references, pointers to references

why use reference instead of pointer?
- no need for unnecessary & and *
------------------------------------------------

------------------------------------------------
Lesson 3: function overloading

The steps C++ compiler takes to find the overloaded function
1. Find function that exactly matches the type of arguments
2. If there is no exact match, check if there is function that matches
after type conversion (casting)
- char, unsigned char, short => int
- unsigned short => int or unsigned int
- float => double
- enum => int
3. Try even more general type conversion to find the function
- number type => number type
- 0 => pointer type or number type
- pointer => void pointer
4. Try user defined type conversion
------------------------------------------------

------------------------------------------------
Lesson 4: Class
class Date {
  int year_;
  int month_;  // 1 부터 12 까지.
  int day_;    // 1 부터 31 까지.

 public:
  void SetDate(int year, int month, int date);
  void AddDay(int inc);
  void AddMonth(int inc);
  void AddYear(int inc);

  // 해당 월의 총 일 수를 구한다.
  int GetCurrentMonthTotalDays(int year, int month);

  void ShowDate();
};

void Date::SetDate(int year, int month, int day) {
  year_ = year;
  month_ = month;
  day_ = day;
}

Why define function outside of class declaration?
- avoid class being too long
- but in the exception of template class, everything is defined within template class
------------------------------------------------

------------------------------------------------
Lesson 5: constructor, copy constructor, destructor

Date(int year, int month, int day) {
  year_ = year;
  month_ = month;
  day_ = day;
}

Ways to initalize instance
Date day(2011, 3, 1);  // implicit       <= preferred
Date day = Date(2012, 3, 1); // explicit

class Test {
 public:
  Test() = default;  // 디폴트 생성자를 정의해라
};

difference between new and malloc
- new not only allocates memory in heap but also calls constructor

destructor

~Marine();
Marine::~Marine() {
  if (name != NULL) {
    delete[] name;
  }
}

copy constructor
T(const T& a);

Photon_Cannon(const Photon_Cannon& pc);

Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}

Photon_Cannon pc1(3, 3); // constructor
Photon_Cannon pc2(pc1); // copy constructor
Photon_Cannon pc3 = pc2; // copy constructor
pc3 = pc2; // nothing

default copy constructor makes a shallow copy.
If we have member field that is dynamically allocated,
we need to define our own copy constructor to make a deep copy.
------------------------------------------------

------------------------------------------------
Lesson 6: initialize list, static member variable

Marine::Marine() : hp(50), coord_x(0), coord_y(0), damage(5), is_dead(false) {}

constructor : var1(arg1), var2(arg2), ... {}

Why use initializer list as opposed to normal constructor?
- initializer list simultaneously construct and initialize
- without initializer list, construct and then assign
- if class has member fields that are either constant or reference, initializer list must be used 
to initialize them

e.g.
using initializer list:
int a = 10;
not using initializer list:
int a;
a = 10;

static member variable belongs to a class, not to a specific instance, and gets destroyed when the program ends.
All instances of the class share a single static member variable.

static function

Usually variables are local and get destroyed when going out of scope.
But static variable does not get destroyed even after going out of scope. 
Moreover static variable gets initialized only once.
It gets stored in the Data segment and gets destroyed when the program ends.
------------------------------------------------

------------------------------------------------
T f() const {
  ...
  return something
}
=> this function does not change values of other vars, can only read
------------------------------------------------

------------------------------------------------
Exercise: Make my own string class
------------------------------------------------


Questions
1. what is typedef and why do I need to use it?
2. what is enum? 
3. NULL vs nullptr

